[{"title":"python类型转换详解","date":"2021-09-20T11:33:55.000Z","url":"/2021/09/20/python%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%A6%E8%A7%A3/","tags":[["python","/tags/python/"],["基础","/tags/%E5%9F%BA%E7%A1%80/"]],"categories":[["undefined",""]],"content":"int支持转换为 int 类型的，仅有 float、str、bytes，其他类型均不支持。 float -&gt; int会去掉小数点及后面的数值，仅保留整数部分。 str -&gt; int如果字符串中有数字(0-9)和正负号(+/-)以外的字符，就会报错。 bytes -&gt; int如果 bytes 中有数字(0-9)和正负号(+/-)以外的字符，就会报错。 float支持转换为 float 类型的，仅有 int、str、bytes，其他类型均不支持。 int -&gt; floatint 转换为 float 时，会自动给添加一位小数。 str -&gt; float如果字符串含有正负号(+/-)、数字(0-9)和小数点(.)以外的字符，则不支持转换。 bytes -&gt; float如果 bytes 中含有正负号(+/-)、数字(0-9)和小数点(.)以外的字符，则不支持转换。 complex仅支持 int、float、str 转换成 complex 类型。 int -&gt; complexint 转换 complex 时，会自动添加虚数部分并以0j表示。 float -&gt; complexfloat 转换 complex 时，会自动添加虚数部分并以0j表示。 str -&gt; complexstr 转换 complex 时，如果能转换成 int 或 float，则会转换后再转为 complex。如果字符串完全符合 complex 表达式规则，也可以转换为 complex 类型值。 strstr() 函数可以将任意对象转换为字符串。 int -&gt; strint 转换 str 会直接完全转换。 float -&gt; strfloat 转换 str 会去除末位为 0 的小数部分。 complex -&gt; strcomplex 转换 str，会先将值转化为标准的 complex 表达式，然后再转换为字符串。 bytes -&gt; strbytes 和 str 的转换比较特殊点，在 Python 3.x 中，字符串和字节不再混淆，而是完全不同的数据类型。 转换为可执行的表达式字符串： str() 函数指定 encoding 参数，或者使用 bytes.decode() 方法，可以作实际数据的转换： list -&gt; str会先将值格式化为标准的 list 表达式，然后再转换为字符串。 tuple -&gt; str会先将值格式化为标准的 tuple 表达式，然后再转换为字符串。 dict -&gt; str会先将值格式化为标准的 dict 表达式，然后再转换为字符串。 set -&gt; str会先将值格式化为标准的 set 表达式，然后再转换为字符串。 其他类型转换内置对象： 转换类实例： 转换函数： bytes仅支持 str 转换为 bytes 类型。 list支持转换为 list 的类型，只能是序列，比如：str、tuple、dict、set等。 str -&gt; list bytes -&gt; listbytes 转换列表，会取每个字节的 ASCII 十进制值并组合成列表 tuple -&gt; listtuple 转换为 list 比较简单。 dict -&gt; list字典转换列表，会取键名作为列表的值。 set -&gt; list集合转换列表，会先去重为标准的集合数值，然后再转换。 tuple与列表一样，支持转换为 tuple 的类型，只能是序列。 str -&gt; tuple bytes -&gt; tuplebytes 转换元组，会取每个字节的 ASCII 十进制值并组合成列表。 list -&gt; tuple dict -&gt; tuple set -&gt; tuple dictstr -&gt; dict 使用 json 模块 使用 json 模块转换 JSON 字符串为字典时，需要求完全符合 JSON 规范，尤其注意键和值只能由单引号包裹，否则会报错。 使用 eval 函数 因为 eval 函数能执行任何符合语法的表达式字符串，所以存在严重的安全问题，不建议。 使用 ast.literal_eval 方法 使用 ast.literal_eval 进行转换既不存在使用 json 进行转换的问题，也不存在使用 eval 进行转换的 安全性问题，因此推荐使用 ast.literal_eval。 list -&gt; dict通过 zip 将 2 个列表映射为字典： 将嵌套的列表转换为字典： tuple -&gt; dict通过 zip 将 2 个元组映射为字典： 将嵌套的元组转换为字典： set -&gt; dict通过 zip 将 2 个集合映射为字典： setstr -&gt; set先将字符切割成元组，然后再去重转换为集合。 bytes -&gt; set会取每个字节的 ASCII 十进制值并组合成元组，再去重。 list -&gt; set先对列表去重，再转换。 tuple -&gt; set先对列表去重，再转换。 dict -&gt; set会取字典的键名组合成集合。 "},{"title":"C++ STL mt19937使用说明","date":"2021-09-19T13:31:04.000Z","url":"/2021/09/19/C-STL-mt19937%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","categories":[["undefined",""]],"content":"​ std::mt19937是伪随机数产生器，用于产生高性能的随机数。 C++11引入。 返回值为unsigned int。 ​ std::mt19937接收一个unsigned int数作为种子。所以可以如下定义： 名称由来 ​ A Mersenne Twister pseudo-random generator of 32-bit numbers with a state size of 19937 bits. ​ mt是因为这个伪随机数产生器基于Mersenne Twister算法。 19937是因为产生随的机数的周期长，可达到2^19937-1。 头文件 例子：产生5个伪随机数 ​ 一种可能结果如下： ​ std::random_device本身是均匀分布整数随机数生成器，通常仅用于播种 ​ 通常一步写成std::mt19937 rng(std::random_device&#123;&#125;()); 例子：使用特定分布的随机数​ 分布有很多种，如均匀分布、正态分布等，可参考()​ 产生特定分布的随机数，需要使用分布函数 ​ 产生正态分布的随机数的例子如下： 正态接收两个参数：均值和标准差，这里分别输入5,2. 一种可能结果如下： 正文优点 ·许可免费，而且对所有它的变体专利免费（除CryptMT外）·几乎无处不在：它被包含在大多数编程语言和库中·通过了包括Diehard测试在内的大多数统计随机性测试（除TestU01测试外）·在应用最广泛的MT19937变体中，周期长达2^19937-1·在MT19937-32的情况下对1 ≤ k ≤ 623，满足k-分布·比其他大多数随机数发生算法要快 k-分布一个周期为P的w位整数的随机序列xi，当满足如下条件时被称为满足v位的k-分布： 假设truncv(x)表示x的前v位形成的数字，并且长度为P的kv位序列：其中每个可能出现的2^kv组合在一个周期内出现相同的次数（除全0序列出现次数次数比其他序列少1次） 缺点 ·需要大量的缓冲器（2.5kib），但在TinyMT版本中修正·吞吐量中等，但在SFMT版本中修正·产生的随机数与seed相关，不能用于蒙特卡洛模拟·由相同的初始序列产生的随机状态几乎相同，但在2002年的更新中对MT算法的初始化进行了改进，使得对于相同的初始序列也能产生不同的随机状态·非加密安全的，除CryptMT外 算法详细本算法基于标准（线性）旋转反馈移位寄存器（twisted generalised feedback shift register/TGFSR）产生随机数 整个算法分为三个阶段（如图所示）：第一阶段：初始化，获得基础的梅森旋转链；第二阶段：对于旋转链进行旋转算法；第三阶段：对于旋转算法所得的结果进行处理； 初始化 首先将传入的seed赋给MT[0]作为初值，然后根据递推式：MT[i] = f × (MT[i-1] ⊕ (MT[i-1] &gt;&gt; (w-2))) + i递推求出梅森旋转链。伪代码如下： 对旋转链执行旋转算法 遍历旋转链，对每个MT[i]，根据递推式：MT[i] = MT[i+m]⊕((upper_mask(MT[i]) || lower_mask(MT[i+1]))A）进行旋转链处理。 其中，“||”代表连接的意思，即组合MT[i]的高 w-r 位和MT[i+1]的低 r 位，设组合后的数字为x，则xA的运算规则为（x0是最低位）： 伪代码为： 对旋转算法所得结果进行处理 设x是当前序列的下一个值，y是一个临时中间变量，z是算法的返回值。则处理过程如下：y := x ⊕ ((x &gt;&gt; u) &amp; d)y := y ⊕ ((y &lt;&lt; s) &amp; b)y := y ⊕ ((y &lt;&lt; t) &amp; c)z := y ⊕ (y &gt;&gt; l)伪代码如下： MT-19937-32实现代码（C语言版） 参考"},{"title":"ssh-keygen 中生成的 randomart image 是什么","date":"2021-09-18T18:35:11.000Z","url":"/2021/09/19/sssh-keygen/","tags":[["ssh","/tags/ssh/"]],"categories":[["undefined",""]],"content":"通常我们在生成 SSH Key 的时候会用到 ssh-keygen 命令，在生成结束后，会输出类似如下的内容，这个 randomart image 是什么呢？ 为什么会有 randomart image相比超长字符串，人们更容易接受图形。让我们对比两幅图片的差异比对比两个超长字符串也要容易的多。这就是为什么现在大家使用二维码，而不是复制粘贴 URL 的原因。 Randomart image 通过将 Key 转换成有规律的图片，让人可以更加容易的、快速的对比 Key 的异同。 趣闻在《The drunken bishop: An analysis of the OpenSSHfingerprint visualization algorithm》中，作者通过一段有趣的故事来表达 randomart image 生成的过程： Peter 主教发现自己在一个封闭的矩形房间内，四面都是墙壁，而地板上又铺满了黑白交替矩形的瓷砖。Peter 主教突然开始头疼——大概应为之前喝了太多的酒——于是开始随意的走动起来。准确的说，他是按照对角走位的方式，就好像国际象棋上的主教一样。当他遇到墙壁的时候，如果他踩着黑瓷砖，就走向白瓷砖，如果踩着白瓷砖就走向黑瓷砖。每次动作之后，他都会在瓷砖上放置一个硬币，记录他踩过这里一次。走了 64 步之后，用完了所有的硬币，Peter 突然醒了过来。多么奇怪的梦！ 相关 What is randomart produced by ssh-keygen?OpenSSH Keys and The Drunken BishopThe drunken bishop: An analysis of the OpenSSHfingerprint visualization algorithm 最后一点说明：其主要原理都发表在 The drunken bishop: An analysis of the OpenSSHfingerprint visualization algorithm"},{"title":"Hello World","date":"2021-09-18T16:46:00.336Z","url":"/2021/09/19/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment"}]